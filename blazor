1. Create a Custom JwtAuthenticationStateProvider

public class JwtAuthenticationStateProvider : AuthenticationStateProvider
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly ITokenService _tokenService;

    public JwtAuthenticationStateProvider(IHttpContextAccessor httpContextAccessor, ITokenService tokenService)
    {
        _httpContextAccessor = httpContextAccessor;
        _tokenService = tokenService;
    }

    public override Task<AuthenticationState> GetAuthenticationStateAsync()
    {
        var token = _tokenService.GetTokenFromCookie(); // Method to get token from cookie

        if (string.IsNullOrEmpty(token))
        {
            var anonymous = new ClaimsIdentity();
            return Task.FromResult(new AuthenticationState(new ClaimsPrincipal(anonymous)));
        }

        var claims = _tokenService.GetClaimsFromToken(token);

        if (claims == null)
        {
            var anonymous = new ClaimsIdentity();
            return Task.FromResult(new AuthenticationState(new ClaimsPrincipal(anonymous)));
        }

        var identity = new ClaimsIdentity(claims, "jwtAuthType");
        var user = new ClaimsPrincipal(identity);

        return Task.FromResult(new AuthenticationState(user));
    }

    public void MarkUserAsAuthenticated(string token)
    {
        var claims = _tokenService.GetClaimsFromToken(token);
        var identity = new ClaimsIdentity(claims, "jwtAuthType");
        var user = new ClaimsPrincipal(identity);

        NotifyAuthenticationStateChanged(Task.FromResult(new AuthenticationState(user)));
    }

    public void MarkUserAsLoggedOut()
    {
        var anonymous = new ClaimsIdentity();
        NotifyAuthenticationStateChanged(Task.FromResult(new AuthenticationState(new ClaimsPrincipal(anonymous))));
    }
}




2. Implement the ITokenService to Handle JWT Token Operations

public interface ITokenService
{
    string GetTokenFromCookie();
    IEnumerable<Claim> GetClaimsFromToken(string token);
}

public class TokenService : ITokenService
{
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly string _jwtSecretKey;

    public TokenService(IHttpContextAccessor httpContextAccessor, IConfiguration configuration)
    {
        _httpContextAccessor = httpContextAccessor;
        _jwtSecretKey = configuration["JwtSettings:SecretKey"];
    }

    public string GetTokenFromCookie()
    {
        return _httpContextAccessor.HttpContext?.Request.Cookies["jwtToken"];
    }

    public IEnumerable<Claim> GetClaimsFromToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.ASCII.GetBytes(_jwtSecretKey);

        try
        {
            var principal = tokenHandler.ValidateToken(token, new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = false,
                ValidateAudience = false,
                ClockSkew = TimeSpan.Zero
            }, out SecurityToken validatedToken);

            return principal.Claims;
        }
        catch
        {
            // Token validation failed
            return null;
        }
    }
}


3. Inject the JwtAuthenticationStateProvider in Startup.cs

public void ConfigureServices(IServiceCollection services)
{
    services.AddHttpContextAccessor();
    services.AddScoped<ITokenService, TokenService>();
    services.AddScoped<AuthenticationStateProvider, JwtAuthenticationStateProvider>();

    services.AddAuthenticationCore(); // Blazor Server-side authentication
    services.AddAuthorizationCore(); // Blazor authorization support
}



4. Set the Authentication State in AuthenticationService

public class AuthenticationService
{
    private readonly ITokenService _tokenService;
    private readonly JwtAuthenticationStateProvider _authenticationStateProvider;
    private readonly IHttpContextAccessor _httpContextAccessor;

    public AuthenticationService(ITokenService tokenService, JwtAuthenticationStateProvider authenticationStateProvider, IHttpContextAccessor httpContextAccessor)
    {
        _tokenService = tokenService;
        _authenticationStateProvider = authenticationStateProvider;
        _httpContextAccessor = httpContextAccessor;
    }

    public void AuthenticateUser(string username, string pinCode)
    {
        // Validate user credentials (this could be through a database)

        // Generate JWT token after validation
        var token = GenerateJwtToken();

        // Set token as cookie
        _httpContextAccessor.HttpContext.Response.Cookies.Append("jwtToken", token, new CookieOptions { HttpOnly = true });

        // Notify AuthenticationStateProvider that user is authenticated
        _authenticationStateProvider.MarkUserAsAuthenticated(token);
    }

    public void LogoutUser()
    {
        // Remove the token from cookies
        _httpContextAccessor.HttpContext.Response.Cookies.Delete("jwtToken");

        // Notify AuthenticationStateProvider that user is logged out
        _authenticationStateProvider.MarkUserAsLoggedOut();
    }

    private string GenerateJwtToken()
    {
        // JWT generation logic here
        return "generated-jwt-token";
    }
}



5. Use <Authorized> Tag in Razor Page
<AuthorizeView>
    <Authorized>
        <h3>Welcome, authenticated user!</h3>
    </Authorized>
    <NotAuthorized>
        <h3>You are not authorized to view this content.</h3>
    </NotAuthorized>
</AuthorizeView>



6. Login and Logout Buttons
<button @onclick="Login">Login</button>
<button @onclick="Logout">Logout</button>

@code {
    [Inject] private AuthenticationService AuthService { get; set; }

    private void Login()
    {
        AuthService.AuthenticateUser("username", "pincode");
    }

    private void Logout()
    {
        AuthService.LogoutUser();
    }
}



